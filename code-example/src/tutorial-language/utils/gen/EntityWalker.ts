// Generated by the ProjectIt Language Generator.
import { EntityEveryConcept } from "../../language/gen";
import {
    MultiplyExpression,
    IfExpression,
    FunctionCallExpression,
    EqualsExpression,
    GreaterThenExpression,
    LessThenExpression,
    ComparisonExpression,
    OrExpression,
    AndExpression,
    DivideExpression,
    PlusExpression,
    BinaryExpression,
    BooleanLiteralExpression,
    NumberLiteralExpression,
    StringLiteralExpression,
    LiteralExpression,
    VariableRef,
    AttributeRef,
    AbsExpression,
    AppliedFeature,
    EntityExpression,
    Variable,
    AttributeWithEntityType,
    Text,
    AttributeWithLimitedType,
    EntityFunction,
    MockEnumeration,
    AttributeType,
    Entity,
    SomeOtherModelUnit,
    EntityModelUnit,
    EntityModel
} from "../../language/gen";
import { EntityWorker } from "./EntityWorker";
import { PiLogger } from "@projectit/core";

const LOGGER = new PiLogger("EntityWalker");

/**
 * Class EntityWalker implements the extended visitor pattern of instances of language Entity.
 * This class implements the traversal of the model tree, classes that implement EntityWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class EntityWalker {
    myWorkers: EntityWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: EntityEveryConcept, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof MultiplyExpression) {
                return this.walkMultiplyExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof IfExpression) {
                return this.walkIfExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof FunctionCallExpression) {
                return this.walkFunctionCallExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof EqualsExpression) {
                return this.walkEqualsExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof GreaterThenExpression) {
                return this.walkGreaterThenExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof LessThenExpression) {
                return this.walkLessThenExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof ComparisonExpression) {
                return this.walkComparisonExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof OrExpression) {
                return this.walkOrExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof AndExpression) {
                return this.walkAndExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof DivideExpression) {
                return this.walkDivideExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof PlusExpression) {
                return this.walkPlusExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof BinaryExpression) {
                return this.walkBinaryExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof BooleanLiteralExpression) {
                return this.walkBooleanLiteralExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof NumberLiteralExpression) {
                return this.walkNumberLiteralExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof StringLiteralExpression) {
                return this.walkStringLiteralExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof LiteralExpression) {
                return this.walkLiteralExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof VariableRef) {
                return this.walkVariableRef(modelelement, includeChildren);
            }
            if (modelelement instanceof AttributeRef) {
                return this.walkAttributeRef(modelelement, includeChildren);
            }
            if (modelelement instanceof AbsExpression) {
                return this.walkAbsExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof AppliedFeature) {
                return this.walkAppliedFeature(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityExpression) {
                return this.walkEntityExpression(modelelement, includeChildren);
            }
            if (modelelement instanceof Variable) {
                return this.walkVariable(modelelement, includeChildren);
            }
            if (modelelement instanceof AttributeWithEntityType) {
                return this.walkAttributeWithEntityType(modelelement, includeChildren);
            }
            if (modelelement instanceof Text) {
                return this.walkText(modelelement, includeChildren);
            }
            if (modelelement instanceof AttributeWithLimitedType) {
                return this.walkAttributeWithLimitedType(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityFunction) {
                return this.walkEntityFunction(modelelement, includeChildren);
            }
            if (modelelement instanceof MockEnumeration) {
                return this.walkMockEnumeration(modelelement, includeChildren);
            }
            if (modelelement instanceof AttributeType) {
                return this.walkAttributeType(modelelement, includeChildren);
            }
            if (modelelement instanceof Entity) {
                return this.walkEntity(modelelement, includeChildren);
            }
            if (modelelement instanceof SomeOtherModelUnit) {
                return this.walkSomeOtherModelUnit(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityModelUnit) {
                return this.walkEntityModelUnit(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityModel) {
                return this.walkEntityModel(modelelement, includeChildren);
            }
        } else {
            LOGGER.error(this, "No worker found.");
        }
    }

    private walkMultiplyExpression(modelelement: MultiplyExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMultiplyExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMultiplyExpression(modelelement);
            }
        }
    }

    private walkIfExpression(modelelement: IfExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeIfExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.condition)) {
            this.walk(modelelement.condition, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.whenTrue)) {
            this.walk(modelelement.whenTrue, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.whenFalse)) {
            this.walk(modelelement.whenFalse, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterIfExpression(modelelement);
            }
        }
    }

    private walkFunctionCallExpression(modelelement: FunctionCallExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeFunctionCallExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterFunctionCallExpression(modelelement);
            }
        }
    }

    private walkEqualsExpression(modelelement: EqualsExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEqualsExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEqualsExpression(modelelement);
            }
        }
    }

    private walkGreaterThenExpression(modelelement: GreaterThenExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeGreaterThenExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterGreaterThenExpression(modelelement);
            }
        }
    }

    private walkLessThenExpression(modelelement: LessThenExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLessThenExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLessThenExpression(modelelement);
            }
        }
    }

    private walkComparisonExpression(modelelement: ComparisonExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeComparisonExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterComparisonExpression(modelelement);
            }
        }
    }

    private walkOrExpression(modelelement: OrExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeOrExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterOrExpression(modelelement);
            }
        }
    }

    private walkAndExpression(modelelement: AndExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAndExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAndExpression(modelelement);
            }
        }
    }

    private walkDivideExpression(modelelement: DivideExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDivideExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDivideExpression(modelelement);
            }
        }
    }

    private walkPlusExpression(modelelement: PlusExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforePlusExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterPlusExpression(modelelement);
            }
        }
    }

    private walkBinaryExpression(modelelement: BinaryExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBinaryExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.left)) {
            this.walk(modelelement.left, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.right)) {
            this.walk(modelelement.right, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBinaryExpression(modelelement);
            }
        }
    }

    private walkBooleanLiteralExpression(modelelement: BooleanLiteralExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeBooleanLiteralExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterBooleanLiteralExpression(modelelement);
            }
        }
    }

    private walkNumberLiteralExpression(modelelement: NumberLiteralExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeNumberLiteralExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterNumberLiteralExpression(modelelement);
            }
        }
    }

    private walkStringLiteralExpression(modelelement: StringLiteralExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeStringLiteralExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterStringLiteralExpression(modelelement);
            }
        }
    }

    private walkLiteralExpression(modelelement: LiteralExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeLiteralExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterLiteralExpression(modelelement);
            }
        }
    }

    private walkVariableRef(modelelement: VariableRef, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeVariableRef(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterVariableRef(modelelement);
            }
        }
    }

    private walkAttributeRef(modelelement: AttributeRef, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAttributeRef(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAttributeRef(modelelement);
            }
        }
    }

    private walkAbsExpression(modelelement: AbsExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAbsExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.expr)) {
            this.walk(modelelement.expr, includeChildren);
        }
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAbsExpression(modelelement);
            }
        }
    }

    private walkAppliedFeature(modelelement: AppliedFeature, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAppliedFeature(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAppliedFeature(modelelement);
            }
        }
    }

    private walkEntityExpression(modelelement: EntityExpression, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityExpression(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.appliedfeature)) {
            this.walk(modelelement.appliedfeature, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityExpression(modelelement);
            }
        }
    }

    private walkVariable(modelelement: Variable, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeVariable(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterVariable(modelelement);
            }
        }
    }

    private walkAttributeWithEntityType(modelelement: AttributeWithEntityType, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAttributeWithEntityType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAttributeWithEntityType(modelelement);
            }
        }
    }

    private walkText(modelelement: Text, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeText(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterText(modelelement);
            }
        }
    }

    private walkAttributeWithLimitedType(modelelement: AttributeWithLimitedType, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAttributeWithLimitedType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAttributeWithLimitedType(modelelement);
            }
        }
    }

    private walkEntityFunction(modelelement: EntityFunction, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityFunction(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.expression)) {
            this.walk(modelelement.expression, includeChildren);
        }
        modelelement.parameters.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityFunction(modelelement);
            }
        }
    }

    private walkMockEnumeration(modelelement: MockEnumeration, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMockEnumeration(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMockEnumeration(modelelement);
            }
        }
    }

    private walkAttributeType(modelelement: AttributeType, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeAttributeType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterAttributeType(modelelement);
            }
        }
    }

    private walkEntity(modelelement: Entity, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntity(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.attributes.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.entAttributes.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.functions.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.int_attrs.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.int_functions.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntity(modelelement);
            }
        }
    }

    private walkSomeOtherModelUnit(modelelement: SomeOtherModelUnit, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeSomeOtherModelUnit(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.somePart)) {
            this.walk(modelelement.somePart, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterSomeOtherModelUnit(modelelement);
            }
        }
    }

    private walkEntityModelUnit(modelelement: EntityModelUnit, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityModelUnit(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.functions.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.entities.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityModelUnit(modelelement);
            }
        }
    }

    private walkEntityModel(modelelement: EntityModel, includeChildren?: (elem: EntityEveryConcept) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityModel(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.units.forEach(p => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        if (!(includeChildren === undefined) && includeChildren(modelelement.extraUnit)) {
            this.walk(modelelement.extraUnit, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityModel(modelelement);
            }
        }
    }
}
