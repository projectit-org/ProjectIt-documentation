// Generated by the ProjectIt Language Generator.
import { PiTyperPart } from "@projectit/core";
import { EntityEveryConcept } from "../../language/gen";
import {
    Entity,
    AttributeType,
    MockEnumeration,
    AbsExpression,
    MultiplyExpression,
    EntityFunction,
    AttributeWithLimitedType,
    Text,
    AttributeWithEntityType,
    Variable,
    EntityExpression,
    AppliedFeature,
    AttributeRef,
    VariableRef,
    LiteralExpression,
    StringLiteralExpression,
    NumberLiteralExpression,
    BooleanLiteralExpression,
    BinaryExpression,
    PlusExpression,
    DivideExpression,
    AndExpression,
    OrExpression,
    ComparisonExpression,
    LessThenExpression,
    GreaterThenExpression,
    EqualsExpression,
    FunctionCallExpression,
    IfExpression
} from "../../language/gen";
import { BaseType, Type } from "../../language/gen";

/**
 * Class EntityTyperPart implements the typer generated from, if present, the typer definition,
 * otherwise this class implements the default typer.
 */
export class EntityTyperPart implements PiTyperPart {
    defaultType: BaseType = AttributeType.ANY;

    /**
     * See interface
     */
    public equalsType(elem1: EntityEveryConcept, elem2: EntityEveryConcept): boolean | null {
        if (this.inferType(elem1) === this.inferType(elem2)) return true;
        return false;
    }

    /**
     * See interface
     */
    public inferType(modelelement: EntityEveryConcept): BaseType | null {
        if (modelelement instanceof Entity) {
            return modelelement;
        }
        if (modelelement instanceof AttributeType) {
            return modelelement;
        }
        if (modelelement instanceof MultiplyExpression) {
            return this.inferType(modelelement.left);
        }
        if (modelelement instanceof IfExpression) {
            return this.inferType(modelelement.whenTrue);
        }
        if (modelelement instanceof FunctionCallExpression) {
            return this.inferType(modelelement.functionDefinition?.referred);
        }
        if (modelelement instanceof ComparisonExpression) {
            return AttributeType.Boolean;
        }
        if (modelelement instanceof DivideExpression) {
            return this.inferType(modelelement.left);
        }
        if (modelelement instanceof PlusExpression) {
            return this.inferType(modelelement.left);
        }
        if (modelelement instanceof BooleanLiteralExpression) {
            return AttributeType.Boolean;
        }
        if (modelelement instanceof NumberLiteralExpression) {
            return AttributeType.Integer;
        }
        if (modelelement instanceof StringLiteralExpression) {
            return AttributeType.String;
        }
        if (modelelement instanceof VariableRef) {
            return this.inferType(modelelement.variable?.referred?.declaredType?.referred);
        }
        if (modelelement instanceof AttributeRef) {
            return this.inferType(modelelement.attribute?.referred?.declaredType?.referred);
        }
        if (modelelement instanceof AbsExpression) {
            return this.inferType(modelelement.expr);
        }
        if (modelelement instanceof Variable) {
            return this.inferType(modelelement.declaredType?.referred);
        }
        if (modelelement instanceof AttributeWithLimitedType) {
            return this.inferType(modelelement.declaredType?.referred);
        }
        if (modelelement instanceof EntityFunction) {
            return this.inferType(modelelement.declaredType?.referred);
        }
        return this.defaultType;
    }

    /**
     * See interface
     */
    public conformsTo(elem1: BaseType, elem2: BaseType): boolean | null {
        if (this.inferType(elem2) === AttributeType.ANY) {
            return true;
        }
        if (this.equalsType(elem1, elem2)) return true;
        return false;
    }

    /**
     * See interface
     */
    public conformList(typelist1: BaseType[], typelist2: BaseType[]): boolean | null {
        if (typelist1.length !== typelist2.length) return false;
        let result: boolean = true;
        for (let index in typelist1) {
            result = this.conformsTo(typelist1[index], typelist2[index]);
            if (result == false) return result;
        }
        return result;
    }

    /**
     * See interface
     */
    public isType(elem: EntityEveryConcept): boolean | null {
        // entries for all types marked as @isType
        if (elem instanceof Entity) {
            return true;
        }
        if (elem instanceof AttributeType) {
            return true;
        }
        return false;
    }
}
